Line 1: type_specifier : INT

int 

Line 1: declaration_list : ID

x

Line 1: declaration_list : declaration_list COMMA ID

x,y

Line 1: declaration_list : declaration_list COMMA ID

x,y,z

Line 1: declaration_list : declaration_list COMMA ID LTHIRD CONST_INT RTHIRD

x,y,z,a[2]

Line 1: declaration_list : declaration_list COMMA ID LTHIRD CONST_INT RTHIRD

x,y,z,a[2],b[3]

Line 1: var_declaration : type_specifier declaration_list SEMICOLON

int x,y,z,a[2],b[3];


Line 1: unit : var_declaration

int x,y,z,a[2],b[3];


Line 1: program : unit

int x,y,z,a[2],b[3];


Line 2: type_specifier : INT

int 

Line 2: declaration_list : ID LTHIRD CONST_INT RTHIRD

q[2]

Line 2: var_declaration : type_specifier declaration_list SEMICOLON

int q[2];


Line 2: unit : var_declaration

int q[2];


Line 2: program : program unit

int x,y,z,a[2],b[3];
int q[2];


Line 3: type_specifier : INT

int 

Line 3: type_specifier : INT

int 

Line 3: parameter_list : type_specifier ID

int x

Line 3: type_specifier : INT

int 

Line 3: parameter_list : parameter_list COMMA type_specifier ID

int x,int y

Line 3: type_specifier : INT

int 

Line 3: parameter_list : parameter_list COMMA type_specifier ID

int x,int y,int z

Line 5: variable : ID

x

Line 5: factor : variable

x

Line 5: unary_expression : factor

x

Line 5: term : unary_expression

x

Line 5: simple_expression : term

x

Line 5: rel_expression : simple_expression

x

Line 5: logic_expression : rel_expression

x

Line 5: expression : logic expression

x

Line 5: statement : RETURN expression SEMICOLON

return x;


Line 5: statements : statement

return x;


Line 6: compound_statement : LCURL statements RCURL

{
  return x;
}





ScopeTable # 1.1
 0 --> < x , ID{disp = 4} > 
 1 --> < y , ID{disp = 6} > 
 2 --> < z , ID{disp = 8} > 



ScopeTable # 1
 0 --> < x , ID{disp = 0} > 
 1 --> < y , ID{disp = 0} > 
 2 --> < z , ID{disp = 0} > 
 7 --> < a , ID{disp = 0} > 
 8 --> < b , ID{disp = 0} > 
 12 --> < f , ID{disp = 0} > 
 23 --> < q , ID{disp = 0} > 


Line 6: func_definition : type_specifier ID LPAREN parameter_list RPAREN compound_statement

int f(int x,int y,int z){
  return x;
}



Line 6: unit : func_definition

int f(int x,int y,int z){
  return x;
}



Line 6: program : program unit

int x,y,z,a[2],b[3];
int q[2];
int f(int x,int y,int z){
  return x;
}



Line 7: type_specifier : FLOAT

float 

Line 7: declaration_list : ID

t

Line 7: var_declaration : type_specifier declaration_list SEMICOLON

float t;


Line 7: unit : var_declaration

float t;


Line 7: program : program unit

int x,y,z,a[2],b[3];
int q[2];
int f(int x,int y,int z){
  return x;
}

float t;


Line 8: type_specifier : INT

int 

Line 10: type_specifier : INT

int 

Line 10: declaration_list : ID

x

Line 10: declaration_list : declaration_list COMMA ID

x,y

Line 10: declaration_list : declaration_list COMMA ID LTHIRD CONST_INT RTHIRD

x,y,z[2]

Line 10: declaration_list : declaration_list COMMA ID

x,y,z[2],p

Line 10: var_declaration : type_specifier declaration_list SEMICOLON

int x,y,z[2],p;


Line 10: statement : var_declaration

int x,y,z[2],p;


Line 10: statements : statement

int x,y,z[2],p;


Line 11: variable : ID

x

Line 11: factor : CONST_INT

1

Line 11: unary_expression : factor

1

Line 11: term : unary_expression

1

Line 11: simple_expression : term

1

Line 11: rel_expression : simple_expression

1

Line 11: logic_expression : rel_expression

1

Line 11: arguments : logic_expression

1

Line 11: factor : CONST_INT

2

Line 11: unary_expression : factor

2

Line 11: term : unary_expression

2

Line 11: simple_expression : term

2

Line 11: rel_expression : simple_expression

2

Line 11: logic_expression : rel_expression

2

Line 11: arguments : arguments COMMA logic_expression

1,2

Line 11: factor : CONST_INT

3

Line 11: unary_expression : factor

3

Line 11: term : unary_expression

3

Line 11: simple_expression : term

3

Line 11: rel_expression : simple_expression

3

Line 11: logic_expression : rel_expression

3

Line 11: arguments : arguments COMMA logic_expression

1,2,3

Line 11: argument_list : arguments

1,2,3

Line 11: factor : ID LPAREN argument_list RPAREN

f(1,2,3)

Line 11: unary_expression : factor

f(1,2,3)

Line 11: term : unary_expression

f(1,2,3)

Line 11: simple_expression : term

f(1,2,3)

Line 11: rel_expression : simple_expression

f(1,2,3)

Line 11: logic_expression : rel_expression

f(1,2,3)

Line 11: expression : variable ASSIGNOP logic_expression

x=f(1,2,3)

Line 11: expression_statement : expression SEMICOLON

x=f(1,2,3);


Line 11: statement : expression_statement

x=f(1,2,3);


Line 11: statements : statements statement

int x,y,z[2],p;
x=f(1,2,3);


Line 12: statement : PRINTLN LPAREN ID RPAREN SEMICOLON

println(x);


Line 12: statements : statements statement

int x,y,z[2],p;
x=f(1,2,3);
println(x);


Line 13: compound_statement : LCURL statements RCURL

{
  int x,y,z[2],p;
  x=f(1,2,3);
  println(x);
}





ScopeTable # 1.2
 0 --> < x , ID{disp = -4} > 
 1 --> < y , ID{disp = -6} > 
 2 --> < z , ID{disp = -8} > 
 22 --> < p , ID{disp = -12} > 



ScopeTable # 1
 0 --> < x , ID{disp = 0} > 
 1 --> < y , ID{disp = 0} > < main , ID{disp = 0} > 
 2 --> < z , ID{disp = 0} > 
 7 --> < a , ID{disp = 0} > 
 8 --> < b , ID{disp = 0} > 
 12 --> < f , ID{disp = 0} > 
 23 --> < q , ID{disp = 0} > 
 26 --> < t , ID{disp = 0} > 


Line 13: func_definition : type_specifier ID LPAREN RPAREN compound_statement

int main(){
  int x,y,z[2],p;
  x=f(1,2,3);
  println(x);
}



Line 13: unit : func_definition

int main(){
  int x,y,z[2],p;
  x=f(1,2,3);
  println(x);
}



Line 13: program : program unit

int x,y,z,a[2],b[3];
int q[2];
int f(int x,int y,int z){
  return x;
}

float t;
int main(){
  int x,y,z[2],p;
  x=f(1,2,3);
  println(x);
}



Line 13: start : program



ScopeTable # 1
 0 --> < x , ID{disp = 0} > 
 1 --> < y , ID{disp = 0} > < main , ID{disp = 0} > 
 2 --> < z , ID{disp = 0} > 
 7 --> < a , ID{disp = 0} > 
 8 --> < b , ID{disp = 0} > 
 12 --> < f , ID{disp = 0} > 
 23 --> < q , ID{disp = 0} > 
 26 --> < t , ID{disp = 0} > 



Total lines: 13
Total errors: 0

